<!DOCTYPE html>
<html>
<head>
<script src="http://d3js.org/d3.v3.min.js"></script>
<link href='http://fonts.googleapis.com/css?family=Lato:300' rel='stylesheet' type='text/css'>
  <style type="text/css">
    body {
      width: 800px;
      margin: 25px auto;
      font-family: 'Lato', sans-serif;
      text-align: center;
    }
    circle {
      fill: steelblue;
      stroke: #fff;
      stroke-width: 1;
    }
    .link {
      stroke: #999;
      stroke-opacity: .6;
    }
  </style>
</head>
<body>
  <h1>Section 3: Exploring positional data encoding, part two</h1>
    <form>
      <label><input type="radio" name="layout" value="fullCircle" checked> Complete Circle </label>
      <label><input type="radio" name="layout" value="horizontalGrouping"> Horizontal Grouping </label>
      <label><input type="radio" name="layout" value="pieGrouping"> A Not-really-working Foci Pie </label>
      <label><input type="radio" name="layout" value="circularLayout"> Circular Layout </label>
    </form>

  <script type="text/javascript">

  var margin = {top: 40, bottom: 10, left: 20, right: 20};
  var width = 800 - margin.left - margin.right;
  var height = 600 - margin.top - margin.bottom;

  var nodes = [],
    foci = [{x: 150, y: 300}, {x: 275, y: 300}, {x: 400, y: 300}, {x: 525, y: 300}, {x: 650, y: 300}];
    fociPie = [{x: 100, y: 100}, {x: 200, y: 200}, {x: 300, y: 300}, {x: 400, y: 400}, {x: 650, y: 300}];

  // Creates sources <svg> element and inner g (for margins)
  var svg = d3.select("body").append("svg")
              .attr("width", width+margin.left+margin.right)
              .attr("height", height+margin.top+margin.bottom)
            .append("g")
              .attr("transform", "translate("+margin.left+","+margin.top+")");

  /////////////////////////

  var force = d3.layout.force()
      .charge(-70)
      .friction(0.95)
      .size([width, height]);

  d3.json("data/countries_2012.json", function(data) {

    // data join
    var node = svg.selectAll(".node")
        .data(data)
        .enter()
        .append("g").attr("class", "node")

    node
      .append("circle")
      .attr("r", 5)

    node
      .append("text")
      .attr("font-size", 10)
      .text(function(d) { return d.name })

    function normalForce() {
      force
        .nodes(data)
        .links([])
        .start()
        .on("tick", normalTick);
    }

    function horizontalForce() {
      force
        .nodes(data)
        .links([])
        .start()
        .on("tick", tick);
    }

    function pieForce() {
      force
        .nodes(data)
        .links([])
        .start()
        .on("tick", pie);
    }

    function normalTick(e) {

        var k = 0.2 * e.alpha;

        svg.selectAll("circle")
        .attr("cx", function(d) { return d.x; })
        .attr("cy", function(d) { return d.y; });

        svg.selectAll("text")
        .attr("x", function(d) { return d.x; })
        .attr("y", function(d) { return d.y; });    
      }

    function tick(e) {

        // the next line, var k = 0.1 * e.alpha, determines how tightly the nodes of a specific category are bunched together. The lower it is, the more loosely something seems to be bunched. 
        var k = 0.2 * e.alpha;

        // console.log("check check");
        
        // applies a custom force alternating between pushing nodes towards one of the four corners
        data.forEach(function(o, i) {

          console.log("yayy you made it");

          if (o.continent == "Asia") {   
            // or should it be o.continent?
            // console.log("check two");
            o.y += (foci[0].y - o.y) * k;
            // array object zero should be asia coordinates
            o.x += (foci[0].x - o.x) * k;
          }
          
          if (o.continent == "Americas") { 
            o.y += (foci[1].y - o.y) * k;
            o.x += (foci[1].x - o.x) * k;
          }

          if (o.continent == "Africa") { 
            o.y += (foci[2].y - o.y) * k;
            o.x += (foci[2].x - o.x) * k;
          }

          if (o.continent == "Europe") { 
            o.y += (foci[3].y - o.y) * k;
            o.x += (foci[3].x - o.x) * k;
          }

          if (o.continent == "Oceania") { 
            o.y += (foci[4].y - o.y) * k;
            o.x += (foci[4].x - o.x) * k;
          }
        });

        svg.selectAll("circle")
        .attr("cx", function(d) { return d.x; })
        .attr("cy", function(d) { return d.y; });

        svg.selectAll("text")
        .attr("x", function(d) { return d.x; })
        .attr("y", function(d) { return d.y; });    
      }
      // end of tick function

      // The if statements can sort stuff out via. continent, but overall, this doesn't really work. What I DO need to do is to figure out how to work d3.layout.pie in order to obtain the correct foci of the separate continent blobs. 
      function pie(e) {

        var k = 0.2 * e.alpha;

        // console.log("check check");
        
        // applies a custom force alternating between pushing nodes towards one of the four corners
        data.forEach(function(o, i) {

          console.log("yayy you made it");

          if (o.continent == "Asia") { 
            // or should it be o.continent?
            // console.log("check two");
            o.y += (fociPie[0].y - o.y) * k;
            // array object zero should be asia coordinates
            o.x += (fociPie[0].x - o.x) * k;
          }

          // I'm thinking that, to make the separate circles, you're going to basically filter the set of data for each continent and for each separate set of data, you're going to run the circle function. You also set different focus points for each of the circles. I've got the focus point thing done here; what next? 
          
          /*
          if (o.continent == "Americas") { 
            o.y += (fociPie[1].y - o.y) * k;
            o.x += (fociPie[1].x - o.x) * k;
          }

          if (o.continent == "Africa") { 
            o.y += (fociPie[2].y - o.y) * k;
            o.x += (fociPie[2].x - o.x) * k;
          }

          if (o.continent == "Europe") { 
            o.y += (fociPie[3].y - o.y) * k;
            o.x += (fociPie[3].x - o.x) * k;
          }

          if (o.continent == "Oceania") { 
            o.y += (fociPie[4].y - o.y) * k;
            o.x += (fociPie[4].x - o.x) * k;
          }
          */
        });

        svg.selectAll("circle")
        .attr("cx", function(d) { return d.x; })
        .attr("cy", function(d) { return d.y; });

        svg.selectAll("text")
        .attr("x", function(d) { return d.x; })
        .attr("y", function(d) { return d.y; });    
      }
      // end of tick function


      function circular_layout() {

        force.stop();

        var r = Math.min(height, width);

        var arc = d3.svg.arc()
                .outerRadius(r);

        var pie = d3.layout.pie()
                .sort(function(a, b) { return a.cat - b.cat;}) // Sorting by categories
                .value(function(d, i) { 
                  // it's fun to experiment with this here: return i for different spacing in each, and return 1 for even spacing
                  return 1;  // We want an equal pie share/slice for each point
                });

        // try using data.nodes, or just data
        placeholder = pie(data).map(function(d, i) {
          // Needed to caclulate the centroid
          d.innerRadius = 0;
          d.outerRadius = r;

          // Building the data object we are going to return
          d.data.x = arc.centroid(d)[0]+width/2;
          d.data.y = arc.centroid(d)[1]+height/2;

        svg.selectAll("circle")
        // you can mess around with the duration if you want to; it's quite fun. My personal favorites are 900 and 2500 for the circle movement transitions
        .transition().duration(1500)
        .attr("cx", function(d) { return d.x; })
        .attr("cy", function(d) { return d.y; });

        svg.selectAll("text")
        .transition().duration(1500)
        .attr("x", function(d) { return d.x; })
        .attr("y", function(d) { return d.y; });  
        })
      }
    // end of experimental circular portion

      // to start off with a normal circle 
      normalForce(); 

      // running functions upon the checking of radio buttons
      d3.select("input[value=\"fullCircle\"]").on("click", normalForce);

      d3.select("input[value=\"horizontalGrouping\"]").on("click", horizontalForce);

      d3.select("input[value=\"pieGrouping\"]").on("click", pieForce);

      d3.select("input[value=\"circularLayout\"]").on("click", circular_layout);
  });

  </script>
</body>
</html>